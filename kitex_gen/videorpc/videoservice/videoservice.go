// Code generated by Kitex v0.3.1. DO NOT EDIT.

package videoservice

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/hh02/minimal-douyin/kitex_gen/videorpc"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return videoServiceServiceInfo
}

var videoServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "VideoService"
	handlerType := (*videorpc.VideoService)(nil)
	methods := map[string]kitex.MethodInfo{
		"CreateVideo":        kitex.NewMethodInfo(createVideoHandler, newCreateVideoArgs, newCreateVideoResult, false),
		"MGetVideo":          kitex.NewMethodInfo(mGetVideoHandler, newMGetVideoArgs, newMGetVideoResult, false),
		"QueryVideoByUserId": kitex.NewMethodInfo(queryVideoByUserIdHandler, newQueryVideoByUserIdArgs, newQueryVideoByUserIdResult, false),
		"QueryVideoByTime":   kitex.NewMethodInfo(queryVideoByTimeHandler, newQueryVideoByTimeArgs, newQueryVideoByTimeResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "video",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.3.1",
		Extra:           extra,
	}
	return svcInfo
}

func createVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videorpc.CreateVideoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videorpc.VideoService).CreateVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateVideoArgs:
		success, err := handler.(videorpc.VideoService).CreateVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateVideoResult)
		realResult.Success = success
	}
	return nil
}
func newCreateVideoArgs() interface{} {
	return &CreateVideoArgs{}
}

func newCreateVideoResult() interface{} {
	return &CreateVideoResult{}
}

type CreateVideoArgs struct {
	Req *videorpc.CreateVideoRequest
}

func (p *CreateVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateVideoArgs) Unmarshal(in []byte) error {
	msg := new(videorpc.CreateVideoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateVideoArgs_Req_DEFAULT *videorpc.CreateVideoRequest

func (p *CreateVideoArgs) GetReq() *videorpc.CreateVideoRequest {
	if !p.IsSetReq() {
		return CreateVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateVideoResult struct {
	Success *videorpc.CreateVideoResponse
}

var CreateVideoResult_Success_DEFAULT *videorpc.CreateVideoResponse

func (p *CreateVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateVideoResult) Unmarshal(in []byte) error {
	msg := new(videorpc.CreateVideoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateVideoResult) GetSuccess() *videorpc.CreateVideoResponse {
	if !p.IsSetSuccess() {
		return CreateVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*videorpc.CreateVideoResponse)
}

func (p *CreateVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func mGetVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videorpc.MGetVideoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videorpc.VideoService).MGetVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MGetVideoArgs:
		success, err := handler.(videorpc.VideoService).MGetVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MGetVideoResult)
		realResult.Success = success
	}
	return nil
}
func newMGetVideoArgs() interface{} {
	return &MGetVideoArgs{}
}

func newMGetVideoResult() interface{} {
	return &MGetVideoResult{}
}

type MGetVideoArgs struct {
	Req *videorpc.MGetVideoRequest
}

func (p *MGetVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MGetVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MGetVideoArgs) Unmarshal(in []byte) error {
	msg := new(videorpc.MGetVideoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MGetVideoArgs_Req_DEFAULT *videorpc.MGetVideoRequest

func (p *MGetVideoArgs) GetReq() *videorpc.MGetVideoRequest {
	if !p.IsSetReq() {
		return MGetVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MGetVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type MGetVideoResult struct {
	Success *videorpc.MGetVideoResponse
}

var MGetVideoResult_Success_DEFAULT *videorpc.MGetVideoResponse

func (p *MGetVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MGetVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MGetVideoResult) Unmarshal(in []byte) error {
	msg := new(videorpc.MGetVideoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MGetVideoResult) GetSuccess() *videorpc.MGetVideoResponse {
	if !p.IsSetSuccess() {
		return MGetVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MGetVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*videorpc.MGetVideoResponse)
}

func (p *MGetVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func queryVideoByUserIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videorpc.QueryVideoByUserIdRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videorpc.VideoService).QueryVideoByUserId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *QueryVideoByUserIdArgs:
		success, err := handler.(videorpc.VideoService).QueryVideoByUserId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QueryVideoByUserIdResult)
		realResult.Success = success
	}
	return nil
}
func newQueryVideoByUserIdArgs() interface{} {
	return &QueryVideoByUserIdArgs{}
}

func newQueryVideoByUserIdResult() interface{} {
	return &QueryVideoByUserIdResult{}
}

type QueryVideoByUserIdArgs struct {
	Req *videorpc.QueryVideoByUserIdRequest
}

func (p *QueryVideoByUserIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in QueryVideoByUserIdArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *QueryVideoByUserIdArgs) Unmarshal(in []byte) error {
	msg := new(videorpc.QueryVideoByUserIdRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QueryVideoByUserIdArgs_Req_DEFAULT *videorpc.QueryVideoByUserIdRequest

func (p *QueryVideoByUserIdArgs) GetReq() *videorpc.QueryVideoByUserIdRequest {
	if !p.IsSetReq() {
		return QueryVideoByUserIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QueryVideoByUserIdArgs) IsSetReq() bool {
	return p.Req != nil
}

type QueryVideoByUserIdResult struct {
	Success *videorpc.QueryVideoByUserIdResponse
}

var QueryVideoByUserIdResult_Success_DEFAULT *videorpc.QueryVideoByUserIdResponse

func (p *QueryVideoByUserIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in QueryVideoByUserIdResult")
	}
	return proto.Marshal(p.Success)
}

func (p *QueryVideoByUserIdResult) Unmarshal(in []byte) error {
	msg := new(videorpc.QueryVideoByUserIdResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QueryVideoByUserIdResult) GetSuccess() *videorpc.QueryVideoByUserIdResponse {
	if !p.IsSetSuccess() {
		return QueryVideoByUserIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QueryVideoByUserIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*videorpc.QueryVideoByUserIdResponse)
}

func (p *QueryVideoByUserIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func queryVideoByTimeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videorpc.QueryVideoByTimeRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videorpc.VideoService).QueryVideoByTime(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *QueryVideoByTimeArgs:
		success, err := handler.(videorpc.VideoService).QueryVideoByTime(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QueryVideoByTimeResult)
		realResult.Success = success
	}
	return nil
}
func newQueryVideoByTimeArgs() interface{} {
	return &QueryVideoByTimeArgs{}
}

func newQueryVideoByTimeResult() interface{} {
	return &QueryVideoByTimeResult{}
}

type QueryVideoByTimeArgs struct {
	Req *videorpc.QueryVideoByTimeRequest
}

func (p *QueryVideoByTimeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in QueryVideoByTimeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *QueryVideoByTimeArgs) Unmarshal(in []byte) error {
	msg := new(videorpc.QueryVideoByTimeRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QueryVideoByTimeArgs_Req_DEFAULT *videorpc.QueryVideoByTimeRequest

func (p *QueryVideoByTimeArgs) GetReq() *videorpc.QueryVideoByTimeRequest {
	if !p.IsSetReq() {
		return QueryVideoByTimeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QueryVideoByTimeArgs) IsSetReq() bool {
	return p.Req != nil
}

type QueryVideoByTimeResult struct {
	Success *videorpc.QueryVideoByTimeResponse
}

var QueryVideoByTimeResult_Success_DEFAULT *videorpc.QueryVideoByTimeResponse

func (p *QueryVideoByTimeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in QueryVideoByTimeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *QueryVideoByTimeResult) Unmarshal(in []byte) error {
	msg := new(videorpc.QueryVideoByTimeResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QueryVideoByTimeResult) GetSuccess() *videorpc.QueryVideoByTimeResponse {
	if !p.IsSetSuccess() {
		return QueryVideoByTimeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QueryVideoByTimeResult) SetSuccess(x interface{}) {
	p.Success = x.(*videorpc.QueryVideoByTimeResponse)
}

func (p *QueryVideoByTimeResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateVideo(ctx context.Context, Req *videorpc.CreateVideoRequest) (r *videorpc.CreateVideoResponse, err error) {
	var _args CreateVideoArgs
	_args.Req = Req
	var _result CreateVideoResult
	if err = p.c.Call(ctx, "CreateVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MGetVideo(ctx context.Context, Req *videorpc.MGetVideoRequest) (r *videorpc.MGetVideoResponse, err error) {
	var _args MGetVideoArgs
	_args.Req = Req
	var _result MGetVideoResult
	if err = p.c.Call(ctx, "MGetVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QueryVideoByUserId(ctx context.Context, Req *videorpc.QueryVideoByUserIdRequest) (r *videorpc.QueryVideoByUserIdResponse, err error) {
	var _args QueryVideoByUserIdArgs
	_args.Req = Req
	var _result QueryVideoByUserIdResult
	if err = p.c.Call(ctx, "QueryVideoByUserId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QueryVideoByTime(ctx context.Context, Req *videorpc.QueryVideoByTimeRequest) (r *videorpc.QueryVideoByTimeResponse, err error) {
	var _args QueryVideoByTimeArgs
	_args.Req = Req
	var _result QueryVideoByTimeResult
	if err = p.c.Call(ctx, "QueryVideoByTime", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
