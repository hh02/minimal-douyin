// Code generated by Kitex v0.3.1. DO NOT EDIT.

package commentservice

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/hh02/minimal-douyin/kitex_gen/commentrpc"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return commentServiceServiceInfo
}

var commentServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "CommentService"
	handlerType := (*commentrpc.CommentService)(nil)
	methods := map[string]kitex.MethodInfo{
		"CreateComment":       kitex.NewMethodInfo(createCommentHandler, newCreateCommentArgs, newCreateCommentResult, false),
		"DeleteComment":       kitex.NewMethodInfo(deleteCommentHandler, newDeleteCommentArgs, newDeleteCommentResult, false),
		"QueryCommentByVideo": kitex.NewMethodInfo(queryCommentByVideoHandler, newQueryCommentByVideoArgs, newQueryCommentByVideoResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "comment",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.3.1",
		Extra:           extra,
	}
	return svcInfo
}

func createCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(commentrpc.CreateCommentRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(commentrpc.CommentService).CreateComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateCommentArgs:
		success, err := handler.(commentrpc.CommentService).CreateComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateCommentResult)
		realResult.Success = success
	}
	return nil
}
func newCreateCommentArgs() interface{} {
	return &CreateCommentArgs{}
}

func newCreateCommentResult() interface{} {
	return &CreateCommentResult{}
}

type CreateCommentArgs struct {
	Req *commentrpc.CreateCommentRequest
}

func (p *CreateCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateCommentArgs) Unmarshal(in []byte) error {
	msg := new(commentrpc.CreateCommentRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateCommentArgs_Req_DEFAULT *commentrpc.CreateCommentRequest

func (p *CreateCommentArgs) GetReq() *commentrpc.CreateCommentRequest {
	if !p.IsSetReq() {
		return CreateCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateCommentResult struct {
	Success *commentrpc.CreateCommentResponse
}

var CreateCommentResult_Success_DEFAULT *commentrpc.CreateCommentResponse

func (p *CreateCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateCommentResult) Unmarshal(in []byte) error {
	msg := new(commentrpc.CreateCommentResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateCommentResult) GetSuccess() *commentrpc.CreateCommentResponse {
	if !p.IsSetSuccess() {
		return CreateCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*commentrpc.CreateCommentResponse)
}

func (p *CreateCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func deleteCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(commentrpc.DeleteCommentRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(commentrpc.CommentService).DeleteComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteCommentArgs:
		success, err := handler.(commentrpc.CommentService).DeleteComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteCommentResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteCommentArgs() interface{} {
	return &DeleteCommentArgs{}
}

func newDeleteCommentResult() interface{} {
	return &DeleteCommentResult{}
}

type DeleteCommentArgs struct {
	Req *commentrpc.DeleteCommentRequest
}

func (p *DeleteCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteCommentArgs) Unmarshal(in []byte) error {
	msg := new(commentrpc.DeleteCommentRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteCommentArgs_Req_DEFAULT *commentrpc.DeleteCommentRequest

func (p *DeleteCommentArgs) GetReq() *commentrpc.DeleteCommentRequest {
	if !p.IsSetReq() {
		return DeleteCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type DeleteCommentResult struct {
	Success *commentrpc.DeleteCommentResponse
}

var DeleteCommentResult_Success_DEFAULT *commentrpc.DeleteCommentResponse

func (p *DeleteCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteCommentResult) Unmarshal(in []byte) error {
	msg := new(commentrpc.DeleteCommentResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteCommentResult) GetSuccess() *commentrpc.DeleteCommentResponse {
	if !p.IsSetSuccess() {
		return DeleteCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*commentrpc.DeleteCommentResponse)
}

func (p *DeleteCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func queryCommentByVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(commentrpc.QueryCommentByVideoIdRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(commentrpc.CommentService).QueryCommentByVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *QueryCommentByVideoArgs:
		success, err := handler.(commentrpc.CommentService).QueryCommentByVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QueryCommentByVideoResult)
		realResult.Success = success
	}
	return nil
}
func newQueryCommentByVideoArgs() interface{} {
	return &QueryCommentByVideoArgs{}
}

func newQueryCommentByVideoResult() interface{} {
	return &QueryCommentByVideoResult{}
}

type QueryCommentByVideoArgs struct {
	Req *commentrpc.QueryCommentByVideoIdRequest
}

func (p *QueryCommentByVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in QueryCommentByVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *QueryCommentByVideoArgs) Unmarshal(in []byte) error {
	msg := new(commentrpc.QueryCommentByVideoIdRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QueryCommentByVideoArgs_Req_DEFAULT *commentrpc.QueryCommentByVideoIdRequest

func (p *QueryCommentByVideoArgs) GetReq() *commentrpc.QueryCommentByVideoIdRequest {
	if !p.IsSetReq() {
		return QueryCommentByVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QueryCommentByVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type QueryCommentByVideoResult struct {
	Success *commentrpc.QueryCommentByVideoIdResponse
}

var QueryCommentByVideoResult_Success_DEFAULT *commentrpc.QueryCommentByVideoIdResponse

func (p *QueryCommentByVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in QueryCommentByVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *QueryCommentByVideoResult) Unmarshal(in []byte) error {
	msg := new(commentrpc.QueryCommentByVideoIdResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QueryCommentByVideoResult) GetSuccess() *commentrpc.QueryCommentByVideoIdResponse {
	if !p.IsSetSuccess() {
		return QueryCommentByVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QueryCommentByVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*commentrpc.QueryCommentByVideoIdResponse)
}

func (p *QueryCommentByVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateComment(ctx context.Context, Req *commentrpc.CreateCommentRequest) (r *commentrpc.CreateCommentResponse, err error) {
	var _args CreateCommentArgs
	_args.Req = Req
	var _result CreateCommentResult
	if err = p.c.Call(ctx, "CreateComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteComment(ctx context.Context, Req *commentrpc.DeleteCommentRequest) (r *commentrpc.DeleteCommentResponse, err error) {
	var _args DeleteCommentArgs
	_args.Req = Req
	var _result DeleteCommentResult
	if err = p.c.Call(ctx, "DeleteComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QueryCommentByVideo(ctx context.Context, Req *commentrpc.QueryCommentByVideoIdRequest) (r *commentrpc.QueryCommentByVideoIdResponse, err error) {
	var _args QueryCommentByVideoArgs
	_args.Req = Req
	var _result QueryCommentByVideoResult
	if err = p.c.Call(ctx, "QueryCommentByVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
