// Code generated by Kitex v0.3.1. DO NOT EDIT.

package followservice

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/hh02/minimal-douyin/kitex_gen/followrpc"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return followServiceServiceInfo
}

var followServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "FollowService"
	handlerType := (*followrpc.FollowService)(nil)
	methods := map[string]kitex.MethodInfo{
		"CreateFollow":  kitex.NewMethodInfo(createFollowHandler, newCreateFollowArgs, newCreateFollowResult, false),
		"DeleteFollow":  kitex.NewMethodInfo(deleteFollowHandler, newDeleteFollowArgs, newDeleteFollowResult, false),
		"QueryFollow":   kitex.NewMethodInfo(queryFollowHandler, newQueryFollowArgs, newQueryFollowResult, false),
		"QueryFollower": kitex.NewMethodInfo(queryFollowerHandler, newQueryFollowerArgs, newQueryFollowerResult, false),
		"CheckFollow":   kitex.NewMethodInfo(checkFollowHandler, newCheckFollowArgs, newCheckFollowResult, false),
		"MCheckFollow":  kitex.NewMethodInfo(mCheckFollowHandler, newMCheckFollowArgs, newMCheckFollowResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "follow",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.3.1",
		Extra:           extra,
	}
	return svcInfo
}

func createFollowHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(followrpc.CreateFollowRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(followrpc.FollowService).CreateFollow(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateFollowArgs:
		success, err := handler.(followrpc.FollowService).CreateFollow(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateFollowResult)
		realResult.Success = success
	}
	return nil
}
func newCreateFollowArgs() interface{} {
	return &CreateFollowArgs{}
}

func newCreateFollowResult() interface{} {
	return &CreateFollowResult{}
}

type CreateFollowArgs struct {
	Req *followrpc.CreateFollowRequest
}

func (p *CreateFollowArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateFollowArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateFollowArgs) Unmarshal(in []byte) error {
	msg := new(followrpc.CreateFollowRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateFollowArgs_Req_DEFAULT *followrpc.CreateFollowRequest

func (p *CreateFollowArgs) GetReq() *followrpc.CreateFollowRequest {
	if !p.IsSetReq() {
		return CreateFollowArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateFollowArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateFollowResult struct {
	Success *followrpc.CreateFollowResponse
}

var CreateFollowResult_Success_DEFAULT *followrpc.CreateFollowResponse

func (p *CreateFollowResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateFollowResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateFollowResult) Unmarshal(in []byte) error {
	msg := new(followrpc.CreateFollowResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateFollowResult) GetSuccess() *followrpc.CreateFollowResponse {
	if !p.IsSetSuccess() {
		return CreateFollowResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateFollowResult) SetSuccess(x interface{}) {
	p.Success = x.(*followrpc.CreateFollowResponse)
}

func (p *CreateFollowResult) IsSetSuccess() bool {
	return p.Success != nil
}

func deleteFollowHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(followrpc.DeleteFollowRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(followrpc.FollowService).DeleteFollow(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteFollowArgs:
		success, err := handler.(followrpc.FollowService).DeleteFollow(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteFollowResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteFollowArgs() interface{} {
	return &DeleteFollowArgs{}
}

func newDeleteFollowResult() interface{} {
	return &DeleteFollowResult{}
}

type DeleteFollowArgs struct {
	Req *followrpc.DeleteFollowRequest
}

func (p *DeleteFollowArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteFollowArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteFollowArgs) Unmarshal(in []byte) error {
	msg := new(followrpc.DeleteFollowRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteFollowArgs_Req_DEFAULT *followrpc.DeleteFollowRequest

func (p *DeleteFollowArgs) GetReq() *followrpc.DeleteFollowRequest {
	if !p.IsSetReq() {
		return DeleteFollowArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteFollowArgs) IsSetReq() bool {
	return p.Req != nil
}

type DeleteFollowResult struct {
	Success *followrpc.DeleteFollowResponse
}

var DeleteFollowResult_Success_DEFAULT *followrpc.DeleteFollowResponse

func (p *DeleteFollowResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteFollowResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteFollowResult) Unmarshal(in []byte) error {
	msg := new(followrpc.DeleteFollowResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteFollowResult) GetSuccess() *followrpc.DeleteFollowResponse {
	if !p.IsSetSuccess() {
		return DeleteFollowResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteFollowResult) SetSuccess(x interface{}) {
	p.Success = x.(*followrpc.DeleteFollowResponse)
}

func (p *DeleteFollowResult) IsSetSuccess() bool {
	return p.Success != nil
}

func queryFollowHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(followrpc.QueryFollowRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(followrpc.FollowService).QueryFollow(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *QueryFollowArgs:
		success, err := handler.(followrpc.FollowService).QueryFollow(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QueryFollowResult)
		realResult.Success = success
	}
	return nil
}
func newQueryFollowArgs() interface{} {
	return &QueryFollowArgs{}
}

func newQueryFollowResult() interface{} {
	return &QueryFollowResult{}
}

type QueryFollowArgs struct {
	Req *followrpc.QueryFollowRequest
}

func (p *QueryFollowArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in QueryFollowArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *QueryFollowArgs) Unmarshal(in []byte) error {
	msg := new(followrpc.QueryFollowRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QueryFollowArgs_Req_DEFAULT *followrpc.QueryFollowRequest

func (p *QueryFollowArgs) GetReq() *followrpc.QueryFollowRequest {
	if !p.IsSetReq() {
		return QueryFollowArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QueryFollowArgs) IsSetReq() bool {
	return p.Req != nil
}

type QueryFollowResult struct {
	Success *followrpc.QueryFollowResponse
}

var QueryFollowResult_Success_DEFAULT *followrpc.QueryFollowResponse

func (p *QueryFollowResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in QueryFollowResult")
	}
	return proto.Marshal(p.Success)
}

func (p *QueryFollowResult) Unmarshal(in []byte) error {
	msg := new(followrpc.QueryFollowResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QueryFollowResult) GetSuccess() *followrpc.QueryFollowResponse {
	if !p.IsSetSuccess() {
		return QueryFollowResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QueryFollowResult) SetSuccess(x interface{}) {
	p.Success = x.(*followrpc.QueryFollowResponse)
}

func (p *QueryFollowResult) IsSetSuccess() bool {
	return p.Success != nil
}

func queryFollowerHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(followrpc.QueryFollowerRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(followrpc.FollowService).QueryFollower(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *QueryFollowerArgs:
		success, err := handler.(followrpc.FollowService).QueryFollower(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QueryFollowerResult)
		realResult.Success = success
	}
	return nil
}
func newQueryFollowerArgs() interface{} {
	return &QueryFollowerArgs{}
}

func newQueryFollowerResult() interface{} {
	return &QueryFollowerResult{}
}

type QueryFollowerArgs struct {
	Req *followrpc.QueryFollowerRequest
}

func (p *QueryFollowerArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in QueryFollowerArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *QueryFollowerArgs) Unmarshal(in []byte) error {
	msg := new(followrpc.QueryFollowerRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QueryFollowerArgs_Req_DEFAULT *followrpc.QueryFollowerRequest

func (p *QueryFollowerArgs) GetReq() *followrpc.QueryFollowerRequest {
	if !p.IsSetReq() {
		return QueryFollowerArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QueryFollowerArgs) IsSetReq() bool {
	return p.Req != nil
}

type QueryFollowerResult struct {
	Success *followrpc.QueryFollowerResponse
}

var QueryFollowerResult_Success_DEFAULT *followrpc.QueryFollowerResponse

func (p *QueryFollowerResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in QueryFollowerResult")
	}
	return proto.Marshal(p.Success)
}

func (p *QueryFollowerResult) Unmarshal(in []byte) error {
	msg := new(followrpc.QueryFollowerResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QueryFollowerResult) GetSuccess() *followrpc.QueryFollowerResponse {
	if !p.IsSetSuccess() {
		return QueryFollowerResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QueryFollowerResult) SetSuccess(x interface{}) {
	p.Success = x.(*followrpc.QueryFollowerResponse)
}

func (p *QueryFollowerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func checkFollowHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(followrpc.CheckFollowRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(followrpc.FollowService).CheckFollow(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CheckFollowArgs:
		success, err := handler.(followrpc.FollowService).CheckFollow(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CheckFollowResult)
		realResult.Success = success
	}
	return nil
}
func newCheckFollowArgs() interface{} {
	return &CheckFollowArgs{}
}

func newCheckFollowResult() interface{} {
	return &CheckFollowResult{}
}

type CheckFollowArgs struct {
	Req *followrpc.CheckFollowRequest
}

func (p *CheckFollowArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CheckFollowArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CheckFollowArgs) Unmarshal(in []byte) error {
	msg := new(followrpc.CheckFollowRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CheckFollowArgs_Req_DEFAULT *followrpc.CheckFollowRequest

func (p *CheckFollowArgs) GetReq() *followrpc.CheckFollowRequest {
	if !p.IsSetReq() {
		return CheckFollowArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CheckFollowArgs) IsSetReq() bool {
	return p.Req != nil
}

type CheckFollowResult struct {
	Success *followrpc.CheckFollowResponse
}

var CheckFollowResult_Success_DEFAULT *followrpc.CheckFollowResponse

func (p *CheckFollowResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CheckFollowResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CheckFollowResult) Unmarshal(in []byte) error {
	msg := new(followrpc.CheckFollowResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CheckFollowResult) GetSuccess() *followrpc.CheckFollowResponse {
	if !p.IsSetSuccess() {
		return CheckFollowResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CheckFollowResult) SetSuccess(x interface{}) {
	p.Success = x.(*followrpc.CheckFollowResponse)
}

func (p *CheckFollowResult) IsSetSuccess() bool {
	return p.Success != nil
}

func mCheckFollowHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(followrpc.MCheckFollowRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(followrpc.FollowService).MCheckFollow(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MCheckFollowArgs:
		success, err := handler.(followrpc.FollowService).MCheckFollow(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MCheckFollowResult)
		realResult.Success = success
	}
	return nil
}
func newMCheckFollowArgs() interface{} {
	return &MCheckFollowArgs{}
}

func newMCheckFollowResult() interface{} {
	return &MCheckFollowResult{}
}

type MCheckFollowArgs struct {
	Req *followrpc.MCheckFollowRequest
}

func (p *MCheckFollowArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MCheckFollowArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MCheckFollowArgs) Unmarshal(in []byte) error {
	msg := new(followrpc.MCheckFollowRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MCheckFollowArgs_Req_DEFAULT *followrpc.MCheckFollowRequest

func (p *MCheckFollowArgs) GetReq() *followrpc.MCheckFollowRequest {
	if !p.IsSetReq() {
		return MCheckFollowArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MCheckFollowArgs) IsSetReq() bool {
	return p.Req != nil
}

type MCheckFollowResult struct {
	Success *followrpc.MCheckFollowResponse
}

var MCheckFollowResult_Success_DEFAULT *followrpc.MCheckFollowResponse

func (p *MCheckFollowResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MCheckFollowResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MCheckFollowResult) Unmarshal(in []byte) error {
	msg := new(followrpc.MCheckFollowResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MCheckFollowResult) GetSuccess() *followrpc.MCheckFollowResponse {
	if !p.IsSetSuccess() {
		return MCheckFollowResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MCheckFollowResult) SetSuccess(x interface{}) {
	p.Success = x.(*followrpc.MCheckFollowResponse)
}

func (p *MCheckFollowResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateFollow(ctx context.Context, Req *followrpc.CreateFollowRequest) (r *followrpc.CreateFollowResponse, err error) {
	var _args CreateFollowArgs
	_args.Req = Req
	var _result CreateFollowResult
	if err = p.c.Call(ctx, "CreateFollow", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteFollow(ctx context.Context, Req *followrpc.DeleteFollowRequest) (r *followrpc.DeleteFollowResponse, err error) {
	var _args DeleteFollowArgs
	_args.Req = Req
	var _result DeleteFollowResult
	if err = p.c.Call(ctx, "DeleteFollow", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QueryFollow(ctx context.Context, Req *followrpc.QueryFollowRequest) (r *followrpc.QueryFollowResponse, err error) {
	var _args QueryFollowArgs
	_args.Req = Req
	var _result QueryFollowResult
	if err = p.c.Call(ctx, "QueryFollow", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QueryFollower(ctx context.Context, Req *followrpc.QueryFollowerRequest) (r *followrpc.QueryFollowerResponse, err error) {
	var _args QueryFollowerArgs
	_args.Req = Req
	var _result QueryFollowerResult
	if err = p.c.Call(ctx, "QueryFollower", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CheckFollow(ctx context.Context, Req *followrpc.CheckFollowRequest) (r *followrpc.CheckFollowResponse, err error) {
	var _args CheckFollowArgs
	_args.Req = Req
	var _result CheckFollowResult
	if err = p.c.Call(ctx, "CheckFollow", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MCheckFollow(ctx context.Context, Req *followrpc.MCheckFollowRequest) (r *followrpc.MCheckFollowResponse, err error) {
	var _args MCheckFollowArgs
	_args.Req = Req
	var _result MCheckFollowResult
	if err = p.c.Call(ctx, "MCheckFollow", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
